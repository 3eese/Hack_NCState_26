import { Request, Response } from 'express';
import { extractTextFromImage, OpenAIRequestError } from '../lib/openai';

const DEFAULT_MAX_IMAGE_BYTES = 5 * 1024 * 1024;
const MAX_IMAGE_BYTES = (() => {
    const raw = Number(process.env.MAX_IMAGE_BYTES);
    if (Number.isFinite(raw) && raw > 0) {
        return raw;
    }
    return DEFAULT_MAX_IMAGE_BYTES;
})();

const ALLOWED_MIME_TYPES = new Set([
    'image/png',
    'image/jpeg',
    'image/gif',
    'image/webp'
]);

const DATA_URL_REGEX = /^data:(image\/[a-z0-9.+-]+);base64,(.+)$/i;

class IngestError extends Error {
    status: number;

    constructor(status: number, message: string) {
        super(message);
        this.status = status;
    }
}

type ParsedImage = {
    dataUrl: string;
    mimeType: string;
    sizeBytes: number;
};

const estimateBase64Bytes = (base64: string): number => {
    const padding = base64.endsWith('==') ? 2 : base64.endsWith('=') ? 1 : 0;
    return Math.max(0, Math.floor((base64.length * 3) / 4) - padding);
};

const detectMimeType = (buffer: Buffer): string | null => {
    if (buffer.length >= 12) {
        if (
            buffer[0] === 0x89 &&
            buffer[1] === 0x50 &&
            buffer[2] === 0x4e &&
            buffer[3] === 0x47 &&
            buffer[4] === 0x0d &&
            buffer[5] === 0x0a &&
            buffer[6] === 0x1a &&
            buffer[7] === 0x0a
        ) {
            return 'image/png';
        }

        if (buffer[0] === 0xff && buffer[1] === 0xd8 && buffer[2] === 0xff) {
            return 'image/jpeg';
        }

        if (buffer[0] === 0x47 && buffer[1] === 0x49 && buffer[2] === 0x46 && buffer[3] === 0x38) {
            return 'image/gif';
        }

        if (
            buffer[0] === 0x52 &&
            buffer[1] === 0x49 &&
            buffer[2] === 0x46 &&
            buffer[3] === 0x46 &&
            buffer[8] === 0x57 &&
            buffer[9] === 0x45 &&
            buffer[10] === 0x42 &&
            buffer[11] === 0x50
        ) {
            return 'image/webp';
        }
    }

    return null;
};

const parseImageContent = (content: unknown): ParsedImage => {
    if (typeof content !== 'string' || content.trim().length === 0) {
        throw new IngestError(400, 'Image content must be a base64 string or data URL.');
    }

    const trimmed = content.trim();
    const match = trimmed.match(DATA_URL_REGEX);
    let mimeType: string | null = null;
    let base64Payload = trimmed;

    if (match) {
        const matchMime = match[1];
        const matchPayload = match[2];
        if (!matchMime || !matchPayload) {
            throw new IngestError(400, 'Invalid image data URL.');
        }
        mimeType = matchMime.toLowerCase();
        base64Payload = matchPayload;
    }

    const normalizedBase64 = base64Payload.replace(/\s+/g, '');

    if (!/^[a-z0-9+/]+={0,2}$/i.test(normalizedBase64)) {
        throw new IngestError(400, 'Invalid base64 image data.');
    }

    const paddedBase64 =
        normalizedBase64.length % 4 === 0
            ? normalizedBase64
            : normalizedBase64.padEnd(normalizedBase64.length + (4 - (normalizedBase64.length % 4)), '=');

    const estimatedBytes = estimateBase64Bytes(paddedBase64);
    if (estimatedBytes === 0) {
        throw new IngestError(400, 'Invalid base64 image data.');
    }

    if (estimatedBytes > MAX_IMAGE_BYTES) {
        throw new IngestError(
            413,
            `Image exceeds ${Math.round(MAX_IMAGE_BYTES / (1024 * 1024))}MB limit.`
        );
    }

    const buffer = Buffer.from(paddedBase64, 'base64');
    if (buffer.length === 0) {
        throw new IngestError(400, 'Invalid base64 image data.');
    }

    if (mimeType === 'image/jpg') {
        mimeType = 'image/jpeg';
    }

    if (!mimeType) {
        mimeType = detectMimeType(buffer);
    }

    if (!mimeType || !ALLOWED_MIME_TYPES.has(mimeType)) {
        throw new IngestError(415, 'Unsupported image type. Allowed: PNG, JPEG, GIF, WEBP.');
    }

    return {
        dataUrl: `data:${mimeType};base64,${paddedBase64}`,
        mimeType,
        sizeBytes: buffer.length
    };
};


export const handleIngest = async (req: Request, res: Response): Promise<void> => {
    try {
        const { inputType, content } = req.body ?? {};

        if (!inputType || typeof inputType !== 'string') {
            res.status(400).json({ status: 'error', message: 'Missing or invalid inputType' });
            return;
        }

        if (content === undefined || content === null) {
            res.status(400).json({ status: 'error', message: 'Missing content payload' });
            return;
        }

        // OpenAI Vision is wired for image OCR. URL scraping remains pending.
        console.log(`[Ingest] Received ${inputType} data. Normalizing...`);

        const mockAnalysis = {
            verdict: 'Unverified',
            trustScore: 40,
            claimSummary: 'This is a mock claim summary generated by the ingest controller.',
            evidenceLinks: [],
            safetyFlags: [
                {
                    type: 'Mock Phishing Risk',
                    description: 'The backend routing is successfully connected, but AI logic is pending.'
                }
            ],
            privacyRisk: {
                score: 'C',
                trackersFound: 2
            }
        };

        if (inputType === 'image' || inputType === 'image_base64' || inputType === 'imageBase64') {
            const parsedImage = parseImageContent(content);
            const ocrText = await extractTextFromImage(parsedImage.dataUrl);

            res.status(200).json({
                status: 'success',
                data: {
                    ...mockAnalysis,
                    ocrText,
                    normalizedPayload: {
                        inputType: 'image',
                        text: ocrText,
                        image: {
                            mimeType: parsedImage.mimeType,
                            sizeBytes: parsedImage.sizeBytes
                        },
                        source: 'openai-vision'
                    }
                }
            });
            return;
        }

        res.status(200).json({
            status: 'success',
            data: {
                ...mockAnalysis,
                normalizedPayload: {
                    inputType,
                    content
                }
            }
        });
    } catch (error) {
        if (error instanceof IngestError) {
            res.status(error.status).json({ status: 'error', message: error.message });
            return;
        }

        if (error instanceof OpenAIRequestError) {
            res.status(error.status).json({ status: 'error', message: error.message });
            return;
        }

        console.error('[Ingest Error]:', error);
        res.status(500).json({ status: 'error', message: 'Internal Server Error' });
    }
};
