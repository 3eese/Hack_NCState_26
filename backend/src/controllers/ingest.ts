import { Request, Response } from 'express';
import { extractTextFromImage, OpenAIRequestError } from '../lib/openai';
import { scrapeUrlContent, ScrapeRequestError } from '../lib/scrape';

const DEFAULT_MAX_IMAGE_BYTES = 5 * 1024 * 1024;
const MAX_IMAGE_BYTES = (() => {
    const raw = Number(process.env.MAX_IMAGE_BYTES);
    if (Number.isFinite(raw) && raw > 0) {
        return raw;
    }
    return DEFAULT_MAX_IMAGE_BYTES;
})();

const ALLOWED_MIME_TYPES = new Set(['image/png', 'image/jpeg', 'image/gif', 'image/webp']);
const IMAGE_INPUT_TYPES = new Set(['image', 'image_base64', 'imagebase64']);
const URL_INPUT_TYPES = new Set(['url', 'link', 'web_url', 'weburl']);
const TEXT_INPUT_TYPES = new Set(['text', 'raw_text', 'rawtext']);

const DATA_URL_REGEX = /^data:(image\/[a-z0-9.+-]+);base64,(.+)$/i;

class IngestError extends Error {
    status: number;

    constructor(status: number, message: string) {
        super(message);
        this.status = status;
    }
}

type ParsedImage = {
    dataUrl: string;
    mimeType: string;
    sizeBytes: number;
};

const estimateBase64Bytes = (base64: string): number => {
    const padding = base64.endsWith('==') ? 2 : base64.endsWith('=') ? 1 : 0;
    return Math.max(0, Math.floor((base64.length * 3) / 4) - padding);
};

const detectMimeType = (buffer: Buffer): string | null => {
    if (buffer.length >= 12) {
        if (
            buffer[0] === 0x89 &&
            buffer[1] === 0x50 &&
            buffer[2] === 0x4e &&
            buffer[3] === 0x47 &&
            buffer[4] === 0x0d &&
            buffer[5] === 0x0a &&
            buffer[6] === 0x1a &&
            buffer[7] === 0x0a
        ) {
            return 'image/png';
        }

        if (buffer[0] === 0xff && buffer[1] === 0xd8 && buffer[2] === 0xff) {
            return 'image/jpeg';
        }

        if (buffer[0] === 0x47 && buffer[1] === 0x49 && buffer[2] === 0x46 && buffer[3] === 0x38) {
            return 'image/gif';
        }

        if (
            buffer[0] === 0x52 &&
            buffer[1] === 0x49 &&
            buffer[2] === 0x46 &&
            buffer[3] === 0x46 &&
            buffer[8] === 0x57 &&
            buffer[9] === 0x45 &&
            buffer[10] === 0x42 &&
            buffer[11] === 0x50
        ) {
            return 'image/webp';
        }
    }

    return null;
};

const parseImageContent = (content: unknown): ParsedImage => {
    if (typeof content !== 'string' || content.trim().length === 0) {
        throw new IngestError(400, 'Image content must be a base64 string or data URL.');
    }

    const trimmed = content.trim();
    const match = trimmed.match(DATA_URL_REGEX);
    let mimeType: string | null = null;
    let base64Payload = trimmed;

    if (match) {
        const matchMime = match[1];
        const matchPayload = match[2];
        if (!matchMime || !matchPayload) {
            throw new IngestError(400, 'Invalid image data URL.');
        }
        mimeType = matchMime.toLowerCase();
        base64Payload = matchPayload;
    }

    const normalizedBase64 = base64Payload.replace(/\s+/g, '');

    if (!/^[a-z0-9+/]+={0,2}$/i.test(normalizedBase64)) {
        throw new IngestError(400, 'Invalid base64 image data.');
    }

    // Some clients omit base64 padding; normalize it before decoding.
    const paddedBase64 =
        normalizedBase64.length % 4 === 0
            ? normalizedBase64
            : normalizedBase64.padEnd(normalizedBase64.length + (4 - (normalizedBase64.length % 4)), '=');

    const estimatedBytes = estimateBase64Bytes(paddedBase64);
    if (estimatedBytes === 0) {
        throw new IngestError(400, 'Invalid base64 image data.');
    }

    if (estimatedBytes > MAX_IMAGE_BYTES) {
        throw new IngestError(413, `Image exceeds ${Math.round(MAX_IMAGE_BYTES / (1024 * 1024))}MB limit.`);
    }

    const buffer = Buffer.from(paddedBase64, 'base64');
    if (buffer.length === 0) {
        throw new IngestError(400, 'Invalid base64 image data.');
    }

    if (mimeType === 'image/jpg') {
        mimeType = 'image/jpeg';
    }

    if (!mimeType) {
        mimeType = detectMimeType(buffer);
    }

    if (!mimeType || !ALLOWED_MIME_TYPES.has(mimeType)) {
        throw new IngestError(415, 'Unsupported image type. Allowed: PNG, JPEG, GIF, WEBP.');
    }

    return {
        dataUrl: `data:${mimeType};base64,${paddedBase64}`,
        mimeType,
        sizeBytes: buffer.length
    };
};

const buildMockAnalysis = () => ({
    verdict: 'Unverified',
    trustScore: 40,
    claimSummary: 'This is a mock claim summary generated by the ingest controller.',
    evidenceLinks: [],
    safetyFlags: [
        {
            type: 'Mock Phishing Risk',
            description: 'The backend routing is successfully connected, but AI logic is pending.'
        }
    ],
    privacyRisk: {
        score: 'C',
        trackersFound: 2
    }
});

export const handleIngest = async (req: Request, res: Response): Promise<void> => {
    try {
        const { inputType, content } = req.body ?? {};

        if (typeof inputType !== 'string' || inputType.trim().length === 0) {
            res.status(400).json({ status: 'error', message: 'Missing or invalid inputType' });
            return;
        }

        if (content === undefined || content === null) {
            res.status(400).json({ status: 'error', message: 'Missing content payload' });
            return;
        }

        const normalizedInputType = inputType.trim().toLowerCase();
        const mockAnalysis = buildMockAnalysis();

        console.log(`[Ingest] Received ${normalizedInputType} data. Normalizing...`);

        if (IMAGE_INPUT_TYPES.has(normalizedInputType)) {
            const parsedImage = parseImageContent(content);
            const ocrText = await extractTextFromImage(parsedImage.dataUrl);

            res.status(200).json({
                status: 'success',
                data: {
                    ...mockAnalysis,
                    normalizedPayload: {
                        inputType: 'image',
                        text: ocrText,
                        image: {
                            mimeType: parsedImage.mimeType,
                            sizeBytes: parsedImage.sizeBytes
                        },
                        source: 'openai-vision'
                    }
                }
            });
            return;
        }

        if (URL_INPUT_TYPES.has(normalizedInputType)) {
            if (typeof content !== 'string' || content.trim().length === 0) {
                throw new IngestError(400, 'URL content must be a non-empty string.');
            }

            const scraped = await scrapeUrlContent(content);
            res.status(200).json({
                status: 'success',
                data: {
                    ...mockAnalysis,
                    normalizedPayload: {
                        inputType: 'url',
                        text: scraped.visibleText,
                        url: {
                            input: scraped.inputUrl,
                            final: scraped.finalUrl,
                            title: scraped.title,
                            description: scraped.description,
                            statusCode: scraped.statusCode,
                            contentType: scraped.contentType,
                            fetchedAt: scraped.fetchedAt
                        },
                        source: 'url-scrape'
                    }
                }
            });
            return;
        }

        if (TEXT_INPUT_TYPES.has(normalizedInputType)) {
            if (typeof content !== 'string' || content.trim().length === 0) {
                throw new IngestError(400, 'Text content must be a non-empty string.');
            }

            res.status(200).json({
                status: 'success',
                data: {
                    ...mockAnalysis,
                    normalizedPayload: {
                        inputType: 'text',
                        text: content.trim(),
                        source: 'raw-text'
                    }
                }
            });
            return;
        }

        throw new IngestError(400, 'Unsupported inputType. Use image, url, or text.');
    } catch (error) {
        if (error instanceof IngestError) {
            res.status(error.status).json({ status: 'error', message: error.message });
            return;
        }

        if (error instanceof ScrapeRequestError) {
            res.status(error.status).json({ status: 'error', message: error.message });
            return;
        }

        if (error instanceof OpenAIRequestError) {
            res.status(error.status).json({ status: 'error', message: error.message });
            return;
        }

        console.error('[Ingest Error]:', error);
        res.status(500).json({ status: 'error', message: 'Internal Server Error' });
    }
};